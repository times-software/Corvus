#------------------------------------------------------------------------------
# Corvus specific control parameters (Corvus specific)
# Organize handler so that 
# 1. translation of generic to internal variables as much as possible.

target_list
% Space separated list with all the target properties requested for this calculation.
% 
{
|X| S ...
|X| ...
} .inp_target_list

title
% Title of this calculation.
{
This is a Corvus calculation |X| P
                             |X| ...
} .inp_title

write_input_only
% If True, write input for each of the top level calculations, then exit.
% Not implemented for all calculations.
{
False |X| L
} .inp_write_input_only
scratch
% Directory for disk scratch for those Handlers that require large amounts of
% disk. If the directory is not present or it can not be created, Corvus reverts
% to the default.
% NOTE: This input variable is not fully implemented yet.
{
. |X| S ...
} .inp_scratch

usesaved
% Use previously calculated data rather than recalculating
{
False |X| L
} .inp_usesaved

# Control of python's multiprocessing module
multiprocessing_ncpu
% Number of processors to use in multiprocessing.
% This should be maximum of the number of cpus on a single 
% node.
{
1 |X| I
} .inp_multiprocessing_ncpu
# Adding the following input tag to facilitate the integration of the different
# versions of corvus. This will help the code run different wfs that could be
# provided by two codes. For example, both abinit and nwchem can produce
# dynamical matrices. This input tag allows us to choose which will be used by
# hand.
usehandlers
% Explicitely declare what Handlers are to be used in the generation of the
% Workflow. This helps the current simple Workflow generator when a given target
% is provided by more than one Handler.
% Current possible values are:
%    Feff, FeffRixs, Dmdw, Abinit, Vasp, Nwchem, Orca
{
|X| S ...
} .inp_usehandlers


#------------------------------------------------------------------------------
# General methodological control parameters

method
% Method used to compute the target. This variable is somewhat context-dependent
% and is ccurrently not fully implemented.
% Current possible values are:
%    dft, mp2, ccsd
{
dft |X| S
} .inp_method

xc
% Exchange-correlation functional to use if the "method" selected is "dft".
% Current possible values are:
%    lda, pbe, b3lyp
{
lda |X| S
} .inp_xc

pspfiles
% List of pseudopotentials for each atom in the system. Each line contains
% the label for the atoms (usually the element % name) and the name of the file
% with the pseudopotential. The required format for the files will depend on the
% Handler used.
{
|X| S S
|X| ...
} .inp_pspfil

scf_conv
% Convergence threshold for SCF cycles (HF, DFT, etc) in au. The value set by
% this variable might be internally overridden if the target requires tighter
% convergence settings.
{
1.0e-5|X| F
} .inp_scf_conv

keep_symm
% Toggle the preservation of initial symmetry in optimizations.
{
True |X| L
} .inp_keep_symm

mt_overlap
% set the muffin-tin overlap for different elements.
{
H 0.8  |X| S F
Li 0.8 |X| S F
|X| ...
}.inp_mt_overlap
constant_volume
% Keep the simulation cell volume constant in cell optimizations.
{
True |X| L
} .inp_constant_volume

nkpoints
% Define the number of k-point in each direction of the grid for reciprocal
% space simulations.
{
1 1 1 |X| I I I
} .inp_nkpoints

nqpoints
% Define the number of q-point perturbations in each direction of the grid for
% density functional perturbation theory (DFPT) simulations.
{
 |X| I I I
} .inp_nqpoints

pw_encut
% Planwave energy cutoff for reciprocal space simulations, in au.
{
15.0 |X| F
} .inp_ecut

numberofconfigurations
% Set the number of configurations used in disordered systems.
{
10 |X| I
}.inp_numberofconfigurations

clusterradius
% Radius of clusters created from cif files.
{
12.0 |X| F
} .inp_clusterradius

#------------------------------------------------------------------------------
# Physical properties (generic by definition)
cif_input
% cif input file name.
{
|X| P
} .inp_cif_input

magmom_by_label
% set spin for elements of a cif file by the label
{
|X| S F
|X| ...
}.inp_magmom_by_label

supercell_dimensions
% supercell dimensions (number of cells in each direction).
{
|X| I I I
} .inp_supercell.dimensions

ismetal
% Toggle whether the system should be treated as a metal or as an insulator.
{
False |X| L
} .inp_ismetal

polarization
% Set 3 different polarization directions to calculate in cartesian coordinates.
% By default, these are set to x, y, z, i.e., 
% polarization{
%    1.0 0.0 0.0
%    0.0 1.0 0.0
%    0.0 0.0 1.0
%}
{
    1.0 0.0 0.0 |X| F F F
    0.0 1.0 0.0 |X| F F F
    0.0 0.0 1.0 |X| F F F
    0.0 0.0 0.0 |X| F F F
    |X| ...
} .inp_polarization
ene_int
% Internal (electronic) energy of the system, in au.
{
|X| F
} .inp_ene_int

cell_vectors
% Normalized simulation cell vector directions. These vectors are scaled using
% the "cell_scaling_iso" and "cell_scaling_abc" input variables to generate the
% simulation cell.
{
|X| F F F
|X| F F F
|X| F F F
} .inp_cell_vectors

cell_struc_opt_flags
% Toggle the optimization of the x, y and z coordinates of each atom in the
% system.
{
|X| L L L
|X| ...
} .inp_cell_struc_opt_flags

cell_struc_xyz_red
% Structure of the simulation cell in reduced coordinates if the system is
% extended and has periodic boundary conditions.
{
|X| S F F F
|X| ...
} .inp_cell_struc_xyz_red

number_of_atoms
% Number of atoms in the system
{
|X| I
} .inp_number_of_atoms

species
% chemical species and number of each species
{
|X| S I
} .inp_species

cell_scaling_iso
% Unitless isotropic scaling of the unit cell.
{
1.0 |X| F
} .inp_cell_scaling_iso

cell_scaling_abc
% Scaling of the a, b an c axes of the simulation cell, in Angstroms.
{
|X| F F F
} .inp_cell_scaling_abc

cell_angles_abc
% Scaling of the a, b an c axes of the simulation cell, in Angstroms.
{
|X| F F F
} .inp_cell_angles_abg

mac_diel_const
% Approximate value of the macroscopic dielectric constant of the system used in
% some methods to accelerate convergence of the SCF cycle.
{
|X| F
} .inp_mac_diel_const

cluster
% Structure of the system is the system is not extended (i. e. is a molecule or
% cluster). The coordinates are in Angstroms, and have xyz format, i.e., 
% Atomic_symbol1 x y z
% Atomic_symbol2 x y z
% .
% .
% .
{
|X| S F F F
|X| ...
} .inp_cluster

absorbing_atom
% Index of the absorbing atom for core spectroscopies such as XANES, EXAFS and
% XES. The index counts from one for the first atom in the associated cluster (see above).
{
|X| I ...
} .inp_absorbing_atom

absorbing_atom_type
% Symbol of atom you would like to calculate the XANES for. Will loop over symmetry unique sites defined
% in the CIF file denoted by cif_input (see below).
{
|X| S ...
} .inp_absorbing_atom_type

charge
% Net charge of the system.
{
0 |X| I
} .inp_charge

absorbing_atom_by_label
% Set the absorber by the label associated with it in the cif file.
% Will set all atoms that have a label that starts with this string as absorbers.
{
|X| S ...
}.inp_absorbing_atom_by_label

atomic_charge
% charge to be placed on each atoms of a given species.
% atomic_symbol charge
% ...
{
|X| S F
|X| ...
} .inp_atomic_charge


multiplicity
% Multiplicity of the system.
{
0 |X| I
} .inp_multiplicity

spectral_broadening
% Broadening used in some spectroscopic methods.
{
0.0 |X| F
} .inp_spectral_broadening

fermi_shift
% Shift of the fermi-energy in eV.
{
|X| F
} .inp_fermi_shift

spin_moment
% spin moments of atomic types
% set spin moment for ferromagnetic systems.
% Only allows one moment per chemical element.
% Z spin_moment
{
|X| I F
|X| ...
} .inp_spin_moment

#
# File input of properties - uses python handler - filereader
#
xanes_file
% file to read xanes from - 2 column file
{
|X| S
} .inp_xanes_file


spectralFunction_file
% file to read spectral function from - 2 column file
{
|X| S
} .inp_spectral_function_file

#
# materials project inputs
#
mp_id
% Single material project id. Can be mp-NNNN or just the number.
{
|X| S
} .inp_mp_id

mp_apikey
% Specify your mp API key. This should probably be done with an environment variable instead for security.
{
|X| S
} .inp_mp_apikey
#------------------------------------------------------------------------------
# Code specific control parameters

# Abinit
abinit.verbatim
% The content of this input variable is passed as is (i. e. "verbatim") into the
% input of all Abinit calculations, and it is meant to help with any Abinit
% input that is currently not implemented in Corvus. Thus, it should be used
% carfully to avoid inconsistencies with the automatically generated input.
% Users should refed to the Abinit manual for information on this extra input.
{
|X| P
} .inp_abinit.verbatim

abinit.ngqpt
% Equivalent to Abinit's ngqpt input variable: Defines the number of q-point
% perturbations in each direction of the grid for density functional
% perturbation theory (DFPT) simulations, and is that equivalent to the general
% "nqpoints" Corvus input variable. Please refer to the Abinit manual for
% further details.
%
% NOTE: This code-specific input variable will be replaced by the general
% "nqpoints" variable in the future.
{
|X| I I I
} .inp_abinit.ngqpt

abinit.ng2qpt
% Equivalent to Abinit's (anaddb) ng2qpt input variable: Defines the number of
% q-point perturbations in each direction of the finer grid for density
% functional perturbation theory (DFPT) simulations. Please refer to the
% Abinit manual for further details.
{
|X| I I I
} .inp_abinit.ng2qpt

#------------------------------------------------------------------------------

# NOTE: FDV
# Commenting this out. I have to find out a good definition for it and it is not
# currently being used.
#dmdw.mustar
#% Set the
#{
#|X| F
#} .inp_dmdw.mustar

#dmdw.ioflag
#{
#0 |X| I
#} .inp_dmdw.ioflag
dmdw.ioflag
% Set the amount of output printed by DMDW. Possible values are:
%   0: Terse, prints out only the desired result (s^2, u^2, etc).
%   1: Verbose, prints out the pole frequencies and weights, as well as
%      estimates of the Einstein temperatures for each path.
% Please refer to the DMDW section of the Feff manual for further details.
%
% NOTE: The current format described below is temporary for compatibility with
% previous versions of Corvus. This will be changed to "Integer" in the future.
{
|X| P
} .inp_dmdw.ioflag

#dmdw.nlanc
#{
#|X| I
#} .inp_dmdw.nlanc
dmdw.nlanc
% Set the number of Lanczos poles (i. e. iterations) in DMDW. Larger values
% usually improve convergence of the target quantity. However, the number of
% poles should not exceed the dimensions of the subspace spanned by the
% projection of the path into the appropriate eigenmodes of the Hessian. This
% means that this variable should always be less than 3*N-6, where N is the
% number of atoms in the system. In practice, a value of 6-8 is sufficient to
% obtain converged mean square relative displacements (MSRD, or s^2) for EXAFS.
% For crystallographic mean square displacements (MSD, or u^2) at least 16 poles
% are usually needed. Please refer to the DMDW section of the Feff manual for
% further details.
%
% NOTE: The current format described below is temporary for compatibility with
% previous versions of Corvus. This will be changed to "Integer" in the future.
{
|X| P
} .inp_dmdw.nlanc

dmdw.paths
% Set up the path descriptors that will generate the list of paths for which
% properties will be calculated. The list has the following form:
%   <Number of descriptors>
%     <Descriptor 1>
%     <Descriptor 2>
%    .
%    .
%
% Each descriptor has the form:
%   <Number of atoms in path> <Atom index 1> ... <Max. path length (Ang)>
%
% The atom indices can take the value 0 which acts as a wildcard for all atoms
% in the system.
%
% Examples:
%
% 2
% 2 1 0   3.0
% 3 2 0 5 6.0
%
% This section defines 2 paths descriptors. The first one generates all paths
% with two atoms, starting in atom 1 and going to all other atoms in the
% systems, but subject to a maximum effective path length of 3.0 Ang. The
% second one generates all paths with three atoms, starting in atom 2 and
% ending in atom 5, while passing trhough all other atoms in the system, but
% with a maximum effective length of 6.0 Ang.
% Using the same syntax atoms can be selected to compute their u^2. For example
% the paths section
%
% 1
% 1 0 0.0
%
% will produce u^2 for all atoms in the system. Please refer to the DMDW
% section of the Feff manual for further details.
%
% NOTE: The current format described below is temporary for compatibility with
% previous versions of Corvus.
{
|X| P
} .inp_dmdw.paths

#dmdw.tempgrid
#{
#|X| I F F
#} .inp_dmdw.tempgrid
dmdw.tempgrid
% Set up the temperature grid to compute the thermal properties in DMDW. It has
% the following form:
%
%   <Number of temperature> <Min. temp.> <Max. temp.>
%
% If the number of desired temperatures is just one, the maximum temperature
% input is not needed. Please refer to the DMDW section of the Feff manual for
% further details.
%
% NOTE: The current format described below is temporary for compatibility with
% previous versions of Corvus.
{
|X| P
} .inp_dmdw.tempgrid

#------------------------------------------------------------------------------

nwchem.basis
% Set the Gaussian basis set to be used in the NWChem calculations. The format
% is the same as in NWChem:
%
% <Atom label> <Basis set name>
%  .
%  .
%
% Please refer to the NWChem manual for further details.
{
|X| S ...
|X| ...
} .inp_nwchem.basis

nwchem.qmd.nstep_nucl
% Set the number of nuclear motion steps in a quantum MD simulation.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.qmd.nstep_nucl

nwchem.qmd.dt_nucl
% Set the time step for nuclear motion in a quantum MD simulation.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.qmd.dt_nucl

nwchem.qmd.targ_temp
% Set the target temperature in a quantum MD simulation.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.qmd.targ_temp

nwchem.qmd.thermostat
% Set the thermostat type to be used in a quantum MD simulation.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.qmd.thermostat

nwchem.qmd.print_xyz
% Toggle printing of xyz coordinates in a quantum MD simulation.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.qmd.print_xyz

nwchem.xc
% Set the exchange correlation potential for an NWChem DFT simulation.

% NOTE: This input variable will be superseded in the future by the more
% general "xc" variable.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.xc

nwchem.mult
% Set the multiplicity of the system for an NWChem DFT simulation.

% NOTE: This input variable will be superseded in the future by the more
% general "multiplicity" variable.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.mult

nwchem.qmd.snapstep
{
|X| S
} .inp_nwchem.qmd.snapstep

nwchem.xas.alpha
{
|X| S
} .inp_nwchem.xas.alpha

nwchem.xas.xrayenergywin
{
|X| F F
} .inp_nwchem.xas.xrayenergywin

nwchem.xas.nroots
{
|X| S
} .inp_nwchem.xas.nroots

nwchem.xas.vec
{
|X| S
} .inp_nwchem.xas.vec

nwchem.iter
{
|X| S
} .inp_nwchem.iter

nwchem.charge
% Set the net charge of the system for an NWChem DFT simulation.

% NOTE: This input variable will be superseded in the future by the more
% general "charge" variable.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.charge

nwchem.xaselem
{
|X| S
} .inp_nwchem.xaselem

#------------------------------------------------------------------------------

# Added by FDV
# FEFF input: Non-standard input for Feff. These tokens are used to split up
# some of the input cards in Feff.
# These should probably considered generic

nuctemp
%
% nuctemp
% {
% temp
%
% Specify the temperature (in K) for the nuclear motion (DW factors).
{
300.0 |X| F
} .inp_nuctemp

debyetemp
%
% debyetemp
% {
% temp
%
% Specify the Debye Model temperature (in K) for the calculation of EXAFS DW
% factors.
{
|X| F
} .inp_debyetemp

dmdw_nlanczos
%
% dmdw_nlanczos
% {
% nLanczos_Interations
%
% Specify the number of Lanczos iterations to be done for the calculation of
% EXAFS DW factors with the dynamical matrix method.
{
6 |X| I
} .inp_dmdw_nlanczos

# FEFF input: Most of these will need to be changed due to the optional paramter
# that appear after the required parameters. Alternatively, we can change the functionality 
# of corvus to allow partial input/ partial default.

feff.MPI.CMD
% MPI command to use for parallel calculations, e.g., mpirun, srun, or mpiexec.
{
|X| S
} .inp_feff.MPI.CMD
feff.MPI.ARGS{
|X| S ...
} .inp_feff.MPI.ARGS

feff.scframp
% Ramp scf radius up to final radius, starting from start_radius,
% and taking n_ramp steps.
% SCFRAMP start_radius n_ramp
{
|X| F I
}.inp_feff.scframp

feff.atoms
%
% feff.atoms
% {
% x1  y1  z1 ipot1
% x2  y2  z2 ipot2
% .
% .
% .
%
% Specify atomic positions in cartesian coordinates (in Angstroms) and
% unique potential indices of each atom in the cluster, one atom per line.
{
|X| F F F I
|X| ...
} .inp_feff.atoms

# HOLE
feff.hole
% DEPRECATED: Use feff.edge instead.
%
% Specify the edge using the hole number ihole, e.g., 
% K-edge : ihole = 1
% L1-edge: ihole = 2
% s02 specifies the EXAFS amplitude reduction factor, and should be set to 1.
{
|X| I F
} .inp_feff.hole

# OVERLAP
feff.overlap
% feff.overlap can be used to construct approximate overlapped atom potentials
% when atomic coordinates are not known or specified. 
% NOTE: This input variable is not fully implemented yet.
{
|X| I
} .inp_feff.overlap

# CONTROL
feff.control
%
% feff.control{ ipot ixsph ifms ipaths igenfmt iff2x }
%
% feff.control lets you run one or more of the feff program modules
% separately. There is a switch for each of six parts of feff:
% 0 means not to run that module, 1 means to run it.
{
|X| I I I I I I
} .inp_feff.control

# EXCHANGE
feff.exchange
% feff.exchange{ iexc vr vi iexc0 }
% Use feff.exchange to change the self-energy used in x-ray absorption
% calculations. ixc is an index specifying the potential model to use for the
% fine structure, and the optional ixc0 is the index of the model to use for
% the background function. The calculated potential can be corrected by adding
% a constant shift to the Fermi level given by vr0 and to a pure imaginary
% "optical" potential (i.e., uniform decay) given by vi0. Typical errors in
% Feff's self-consistent Fermi level estimate are about 1 eV.
% (The feff.corrections input is similar but allows the user to make small
% changes in vi0 and vr0 after the rest of the calculation is completed, for
% example in a fitting process.)
%
% Indices for the available exchange models:
%   0 Hedin-Lundqvist + a constant imaginary part
%   1 Dirac-Hara + a constant imaginary part
%   2 ground state + a constant imaginary part
%   3 Dirac-Hara + HL imag part + a constant imaginary part
%   5 Partially nonlocal: Dirac-Fock for core + HL for valence electrons + a
%     constant imaginary part
{
|X| I F F I
} .inp_feff.exchange

# ION
feff.ion
% feff.ion{ ipot ionization }
% feff.ion ionizes all atoms with unique potential index ipot.
% NOTE: This input variable is not fully implemented yet.
{
|X| I F
|X| ...
} .inp_feff.ion

# TITLE
feff.title
% Set title for this feff calculation.
{
|X| S ...
|X| ...
} .inp_feff.title

# FOLP
feff.folp
% feff.folp{ ipot overlap }
% Set the overlap for unique potential ipot.
{
|X| I F
|X| ...
} .inp_feff.folp

# RPATH
feff.rpath
% feff.rpath{ rmax }
% Set maximum path length for path expansion calculations of EXAFS, EXELFS,
% DAFS, etc.
{
|X| F
} .inp_feff.rpath

# DEBYE
feff.debye
% feff.debye{ Temperature Debye-Temperature idwopt }
% Set temperature and Debye temperature for calculations of EXAFS Debye-Waller
% factors.
%   idwopt - set method for calculating DW factors. 
% NOTE: This input variable is not fully implemented yet.
{
|X| S ...
} .inp_feff.debye

# Separate inp for DMDW
feff.dmdw
% NOTE: This input variable is not fully implemented yet.
{
|X| S I I I
} .inp_feff.dmdw

# RMULT
feff.rmultiplier
% feff.rmultiplyer{ rmult }
% Multiply coordinates of all atoms by rmult, expanding or contracting the
% system.
{
|X| F
} .inp_feff.rmultiplier

# SS
feff.ss
% Set an 
{
|X| I I F F
|X| ...
} .inp_feff.ss

# PRINT
feff.print
% feff.pring{ ipr_pot ipr_xsph ipr_fms ipr_path ipr_genfmt ipr_ff2x }
% Set print level for each module of FEFF:
%   pot: 
%     0 write 'pot.bin' only
%     1 add 'misc.dat'
%     2 add 'potNN.dat'
%     3 add 'atomNN.dat'
% 
%   xsph:
%     0 write 'phase.bin' and 'xsect.bin' only
%     1 add 'axafs.dat' and 'phase.dat'
%     2 add 'phaseNN.dat' and 'phminNN.dat'
%     3 add 'ratio.dat' (for XMCD normalization) and 'emesh.dat'.
% 
%   fms:
%     0 write 'gg.bin'
%     1 write 'gg.dat'
% 
%   path:
%     0 write 'paths.dat' only
%     1 add 'crit.dat'
%     3 add 'fbeta' files (plane wave |f(\beta)| approximations)
%     5 Write only 'crit.dat' and do not write 'paths.dat'. (This is useful
%       genfmt 0 write 'list.dat', and write 'feff.bin' with all paths with
%       importance greater than or equal to two thirds of the curved wave
%       importance criterion
%
%   genfmt:
%     0 write 'list.dat', and write 'feff.bin' with all paths with importance
%       greater than or equal to two thirds of the curved wave importance
%       criterion
%     1 write all paths to 'feff.bin'
% 
%   ff2x:
%     0 write 'chi.dat' and 'xmu.dat'
%     2 add 'chipNNNN.dat' (chi(k) for each path individually)
%     3 add 'feffNNNN.dat' and 'files.dat', and do not add 'chipNNNN.dat'
%       files
{
|X| I I I I I I
} .inp_feff.print

#
# potentials: should have one more F at the end for spinph. Leaving that off for now.
feff.potentials
% feff.potentials{
%   ipot iz pot_label lfms1 lfms2 stoichiometry
%   ...
% }
% Set unique potentials for FEFF calculation.
%
{
|X| I I S I I F
|X| ...
} .inp_feff.potentials

feff.potentials.spin
% feff.potentials.spin{
%  ipot spin_moment
%  ...
% }
% Set spin moments of atoms defined in potentials card
{
|X| I F
|X| ...
} .inp_feff.potentials.spin


feff.lfms1
% set maximum angular momentum to use in potentials
{
-1 |X| I
} .inp_feff.lfms1


feff.lfms2
% set maximum angular momentum to use in FMS
{
-1 |X| I
} .inp_feff.lfms2

# NLEG
feff.nleg
% feff.nleg{ nleg }
% Set maximum number of legs to use in path expansion. A Single scattering
% path has 2 legs.
{
|X| I
} .inp_feff.nleg

# CRITERIA
feff.criteria
% feff.criteria{ critcw critpw }
% Cutoff criteria for the path expansion filtering. 
% critcw - tolerance for curved wave expansion
% critpw - tolerance for initial plane wave approximation
{
|X| F F
} .inp_feff.criteria

# NOGEOM - leave out for now.
#feff.nogeom
#{
#.false. |X| L
#} .inp_feff.nogeom

# IORDER
feff.iorder
% feff.iorder{ iorder }
% Set order of approximation when calculating effective scattering matrices.
{
|X| I
} .inp_feff.iorder

# PCRITERIA
feff.pcriteria
% feff.pcriteria{ pcritk pcrith }
% Set criteria for filtering in pathfinder. The keep-criterion pcritk looks at
% the amplitude of chi (in the plane wave approximation) for the current path
% and compares it to a single scattering path of the same effective length.
% To set this value, consider the maximum degeneracy you expect and divide
% your plane wave criterion by this number. For example, in fcc Cu, typical
% degeneracies are 196 for paths with large r, and the minimum degeneracy is 6.
% So a keep criterion of 0.08% is appropriate for a pw criteria of 2.5%. The
% heap-criterion pcrith filters paths as the pathfinder puts all paths into a
% heap (a partially ordered data structure), then removes them in order of
% increasing total path length. Each path that is removed from the heap is
% modified and then considered again as part of the search algorithm. The heap
% filter is used to decide if a path has enough amplitude in it to be worth
% further consideration. If a path can be eliminated at this point, entire
% trees of derivative paths can be neglected, leading to enormous time savings.
% This test does not come into play until paths with at least 4 legs are being
% considered, so single scattering and triangular (2 and 3 legged) paths will
% always pass this test. Because only a small part of a path is used for
% this criterion, it is difficult to predict what appropriate values will be. 
{
|X| F F 
} .inp_feff.pcriteria

# SIG2
feff.sig2
% feff.sig2{ sig2 }
% Set a single Debye-Waller factor for all paths, exp{-2*sig2*k**2}.
{
|X| F
} .inp_feff.sig2

# XANES
feff.xanes
% feff.xanes{ xkmax }
% Calculate XANES spectrum.
%   xkmax - calculate up to k = xkmax
{
|X| F
} .inp_feff.xanes

# CORRECTIONS
feff.corrections
% feff.corrections{ vrcorr vicorr }
% Correct the Fermi cutoff and broadening in the final spectrum calculation.
% vrcorr - Shift Fermi cutoff by -vrcorr. 
% vicorr - Add extra Lorenzian broadening with half width at half max of vicorr. 
{
|X| F F
} .inp_feff.corrections

# AFOLP
feff.afolp
% feff.afolp{ folpx }
% Set maximum overlap for automatic overlap search.
% folpx - maximum overlap allowed.
{
|X| F
} .inp_feff.afolp

# EXAFS
feff.exafs
% feff.exafs{ xkmax xkstep }
% Calculate EXAFS spectrum.
% xkmax  - calculate spectrum up to k = xkmax
% xkstep - calculate in steps of xkstep
{
|X| F F
} .inp_feff.exafs

# POLARIZATION
feff.polarization
% feff.polarization{ x y z }
% Set polarization vector of x-rays in cartesian coordinates of input file.
{
|X| F F F
} .inp_feff.polarization

# ELLIPTICITY
feff.ellipticity
% feff.ellipticity{ elpty x y z }
% Set the ellipticity of the x-rays.
% This card is used with the feff.polarization. 
%   elpty   - ratio of amplitudes of electric field in the two orthogonal
%             directions of elliptically polarized light. Only the absolute
%             value of the ratio is important for nonmagnetic materials. The
%             present code can distinguish left- and right-circular polarization
%             only with the feff.xmcd or feff.xncd. A zero value of the
%             ellipticity corresponds to linear polarization, and unity to
%             circular polarization. The default value is zero.
%   x, y, z - coordinates of any nonzero vector in the direction of the
%             incident beam. This vector should be approximately normal to the
%             polarization vector
{
|X| F F F F
} .inp_feff.ellipticity

# RGRID
feff.rgrid
{
|X| F
} .inp_feff.rgrid

# RPHASES
feff.rphases
% feff.rphases{ UseRealPhases }
% Set real phase shift approximation.
% UseRealPhases - use real phase shift if true.
{
|X| L
} .inp_feff.rphases

# NSTAR
feff.nstar
% feff.nstar{ WriteNStar }
% Write nstar.dat with effective coordination number N*.
{
|X| L
} .inp_feff.nstar

# NOHOLE
feff.nohole
% feffnohole{ UseNoHole }
% Do not use a hole in the calculation.
% DEPRECATED - Use feff.corehole instead.
{
|X| L
} .inp_feff.nohole

# SIG3
feff.sig3
% feff.sig3{ alphat thetae }
% Set first and third cumulants for single scattering paths:
%   alphat - first cumulant
%   thetae - third cumulant
{
|X| F F
} .inp_feff.sig3

# JUMPRM
feff.jumprm
% feff.jumprm{ UseRemoveJump }
% If true, smooth the jump between muffin tin potentials and interstitial.
{
|X| L
} .inp_feff.jumprm

# MBCONV
feff.mbconv
% Deprecated: Should not be used.
{
|X| L
} .inp_feff.mbconv 

# SPIN
feff.spin
% feff.spin{ ispin sx sy sz }
% Specify the type of spin-dependent calculation for spin along the (x, y, z) 
% direction, along the z-axis by default. The SPIN card is required for the
% calculation of all spin-dependent effects, including XMCD and SPXAS.
%   ispin:
%      2 spin-up SPXAS and LDOS
%     -2 spin-down SPXAS and LDOS
%      1 spin-up portion of XMCD calculations
%     -1 spin-down portion of XMCD calculations
{
|X| I F F F
} .inp_feff.spin

# EDGE
feff.edge
% feff.edge{ edgeLabel }
% Set edge to calculate for XAS, XES, EELS, and other related spectra.
{
|X| S ...
} .inp_feff.edge

# SCF
feff.scf
% feff.scf{ rfms1 lfms1 nscmt ca nmix }
% Use self-consistent field calculation of potentials.
%   rfms1 - radius of cluster to use for scf calculations.
%   lfms1 - 0 for solids, 1 for molecules
%   nscmt - maximum number of iterations in SCF calculation.
%   ca    - convergence factor for Broyden algorithm
%   nmix  - number of initial iterations of mixing algorithm to use.
{
|X| F I I F I
} .inp_feff.scf

# FMS
feff.fms
% feff.fms{ rfms lfms2 minv toler1 toler2 rdirec }
% Use full multiple-scattering.
% rfms   - radius of cluster to use for fms calculation.
% lfms1  - 0 for solids, 1 for molecules
% minv   - set algorithm for matrix inversion
%          0: LU decomposition
%          2: Lanczos
%          3: Broyden (less reliable)
% toler1 - tolerance to stop recursion and Broyden algorithm
% toler2 - sets the matrix element of the Gt matrix to zero if its value is
%          less than toler2
% rdirec - sets the matrix element of the Gt matrix to zero if the distance
%          between atoms is larger than rdirec
{
|X| F I I F F F
} .inp_feff.fms

# LDOS
feff.ldos
% feff.ldos{ emin emax broadening npoints }
% Run angular momentum project density of states calculations.
% emin       - minimum energy of energy grid.
% emax       - maximum energy of energy grid.
% broadening - Lorenzian broadening to use in calculation.
% npoints    - number of energy points in grid. 
{
|X| F F F I
} .inp_feff.ldos

# INTERSTITIAL
feff.interstitial
% feff.interstitial{ inters vtot }
% The construction of the interstitial potential and density may be changed by
% using this card. inters = 1 might be useful when only the surroundings of the
% absorbing atom are specified in 'feff.inp'. inters defines how to find the
% interstitial potential.
%    inters=0: The interstitial potential is found by averaging over the
%              entire extended cluster in 'feff.inp'. (Default)
%    inters=1: the interstitial potential is found locally around the
%              absorbing atom.
%    vtot:     the volume per atom normalized by ratmin3
%              (vtot=(volume per atom)/ratmin3), where ratmin is the shortest
%              bond for the absorbing atom. This quantity defines the total
%              volume (needed to calculate the interstitial density) of the
%              extended cluster specified in 'feff.inp'. If vtot <= 0 then the
%              total volume is calculated as a sum of Norman sphere volumes.
%              Otherwise, total volume = nat * (vtot * ratmin3), where nat is
%              the number of atoms in an extended cluster.
{
|X| I F
} .inp_feff.interstitial

# CFAVERAGE
feff.cfaverage
% Obsolete: Do not use.
{
|X| I I F
} .inp_feff.interstitial

# S02
feff.s02
% feff.s02{ s02 }
% Set EXAFS amplitude reduction factor.
{
|X| F
} .inp_feff.s02

# XES
feff.xes
% feff.xes{ emin emax estep }
% Calculate x-ray emission spectrum.
%   emin  - minimum energy of calculation.
%   emax  - maximum energy of calculation
%   estep - energy step of calculation
{
|X| F F F
} .inp_feff.xes

# DANES
feff.danes
% feff.danes{ xkmax xkstep estep }
% Calculate diffraction anomalous near edge structure.
% xkmax  - calculate up to k = xkmax
% xkstep - use steps of size xkstep
% estep  - near the edge, use steps calculated from estep
{
|X| F F F
} .inp_feff.danes

# FPRIME
feff.fprime
% feff.fprime{ emin emax estep }
% emin  - minimum energy of calculation.
% emax  - maximum energy of calculation
% estep - energy step of calculation
% Calculate atomic scattering factor f'
{
|X| F F F
} .inp_feff.fprime

# RSIGMA
feff.rsigma
% feff.rsigma{ UseRealSelfEnergy }
% If true use only real part of self-energy.
{
|X| L
} .inp_feff.rsigma

# XMCD
feff.xmcd
% feff.xmcd{ xkmax xkstep estep }
% Caluclate x-ray magnetic (or natural) circular dichroism
%   xkmax  - calculate up to k = xkmax
%   xkstep - use steps of size xkstep
%   estep  - near the edge, use steps calculated from estep
{
|X| F F F
} .inp_feff.xmcd

# MULTIPOLES
feff.multipole
% feff.multipole{ le2 l2lp }
% Set multipole expansion approximation. Specifies which multipole transitions
% to include in the calculations. The options are: only dipole (le2 = 0,
% default), dipole and magnetic dipole (le2 = 1), dipole and quadrupole
% (le2 = 2). This cannot be used with NRIXS and is not supported with EXELFS
% and ELNES. The additional field l2lp can be used to calculate individual
% dipolar contributions coming from L -> L + 1 (l2lp = 1) and from L -> L - 1
% (l2lp = -1). Notice that in polarization dependent data there is also a
% cross term, which is calculated only when l2lp = 0
{
|X| I I
} .inp_feff.multipole

# UNFREEZEF
feff.unfreezef
% feff.unreezef{ UnfreezeFOrbitals }
% If true, allow f-orbitals to relax during SCF calculation.
{
|X| L
} .inp_feff.unfreezef

# TDLDA
feff.tdlda
% feff.tdlda{ ifxc }
% Use TDLDA to calculate x-ray absorption spectrum.
% ifxc - set algorithm for tdlda approximation
%        0: use static approximation for screening of the x-ray field
%        1: use approximate dynamic screening of x-ray field and core-hole. 
{
|X| I
} .inp_feff.tdlda

# PMBSE
feff.pmbse
{
|X| I I I I
} .inp_feff.pmbse

# MPSE
feff.mpse
% feff.mpse{ ipl npl }
% Use many-pole model self-energy. This requires the loss function, which can
% be provided externally, or approximated using feff.opcons.
%   ipl - Set method for self-energy inclusion:
%          1: use an "average" self-energy which is applied to the whole
%             system (default). 
%          2: use a density dependendent self-energy which is
%             different at every point inside the muffin-tin radius.
{
|X| I I
} .inp_feff.mpse

# SFCONV
feff.sfconv
% feff.sfconv{ UseSpectralFunctionConvolution }
% If true, convolve spectrum with spectral function to account for
% multi-electron excitations.
{
|X| L
} .inp_feff.sfconv

# SELF
feff.self
% feff.self{ PrintSelfEnergy }
% Print out quasiparticle self-energy calculated during spectral-function
% convolution calculations.
{
|X| L
} .inp_feff.self

# SFSE
feff.sfse
% feff.sfse{ k }
% Print out off shell self-energy Sigma(k,E) calculated during
% spectral-function convolution calculations.
{
|X| F
} .inp_feff.sfse

# RCONV
feff.rconv
% Advanced: Print running convolution with the spectral function.
{
|X| F S
} .inp_feff.rconv

# ELNES
feff.elnes
% This card is not implements yet.
{
|X| F F F
|X| S ...
|X| ...
# In future, fix so that we actually have these params, not just strings.
} .inp_feff.elnes

# EXELFS
feff.exelfs
% This card is not implemented yet.
{
|X| F
|X| S
|X| ...
# In future, fix so that we actually have these params, not just strings.
} .inp_feff.exelfs

# MAGIC
feff.magic
% This card is not implemented yet.
{
|X| F
} .inp_feff.magic

# ABSOLUTE
feff.absolute
% feff.absolue{ UseAbsoluteUnits }
% Print spectrum in absolute units instead of normalizing.
{
|X| L
} .inp_feff.absolute

# SYMMETRY
feff.symmetry
% feff.symmetry{ UseSymmetry }
% If false, turn off symmetry considerations in path expansion.
{
|X| L
} .inp_feff.symmetry

# REAL
feff.real
% Advanced: Use real phase shifts.
{
|X| L
} .inp_feff.real

# RECIPROCAL
feff.reciprocal
% Work in reciprocal space (k-space calculation).
{
|X| L
} .inp_feff.reciprocal

# SGROUP
feff.sgroup
% Specify space group by number (1 - 230).
{
|X| L
} .inp_feff.sgroup

# LATTICE
feff.lattice
% This card specifies the lattice. First, its type must be specified using a single letter : P for
% primitive, F for face centered cubic, I for body centered cubic, H for hexagonal. The following
% three lines give the three basis vectors in Carthesian Angstrom coordinates. They are multiplied
% by scale (e.g., 0.529177 to convert from bohr to Angstrom).
% feff.lattice{ P 3.18800
% ax ay az
% bx by bz
% cx cy cz
{
# Need to fix this so that all parameters are set in separate fields.
|X| S
|X| ...
} .inp_feff.lattice

# KMESH
feff.kmesh
% Specify the kmesh.
% feff.kmesh nkp(x) [nkpy nkpz [ktype [usesym] ] ]
% This card specifies the mesh of k-vectors used to sample the full Brillouin Zone for the evaluation
% of Brillouin Zone integrals. Nkp is the number of points used in the full zone. It can be specified
% either as ”nkpx nkpy nkpz”, ”nkp”, or ”nkp 0 0”. If usesym = 1, the zone is reduced to its
% irreducible wedge using the symmetry options specified in file symfile, which must be present
% in the working directory. The k-mesh is constructed using the tetrahedron method of Bloechl
% et al., Phys. Rev. B, 1990. The parameter ktype is meant for time-saving only and means:
%  ktype=1 : regular mesh of nkp points for all modules
%  ktype=2 : use nkp points for ldos/fms and nkp/5 points for pot (significant time savings)
%  ktype=3 : use nkp points for ldos/fms and nkp/5 points for pot (near edge) ; reduce nkp
% for all modules as we get away from near-edge (somewhat experimental)
% * use a k-mesh of 1000 points in the full BZ.
% feff.kmesh{ 1000 }
% * use a k-mesh of 10x5x3 points for a large, irregular cell.
% feff.kmesh{ 10 5 3 }
% * use a k-mesh of 1000 points and try to save time:
% feff.kmesh{ 1000 0 0 3 }
{
|X| I ... 
} .inp_feff.kmesh

# STRFAC
feff.strfac
% feff.strfac{ eta gmax rmax }
% This card gives three non-physical internal parameters for the calculation of the KKR structure
% factors : the Ewald parameter and a multiplicative cutoff factor for sums over reciprocal (gmax)
% and real space (rmax) sums. Multiplicative means the code makes a ’smart’ guess of a cutoff
% radius, but if one suspects something fishy is going on, one can here e.g. use gmax=2 to multiply
% this guess by 2. Eta is an absolute number. Given the stability of the Ewald algorithm, it
% shouldn’t be necessary to use this card. Its use is not recommended. Only active in combination
% with the feff.reciprocal card.
{
|X| F F F
} .inp_feff.strfac

# BANDSTRUCTURE
#feff.bandstructure
#{
# For future ...
#}

# COREHOLE
feff.corehole
% feff.corehole{ CoreHoleApproximation }
% Set method for calculating corehole interaction.
% CoreHoleApproximation -
%                         None: Do not use a corehole.
%                         FSR : Final-state rule
%                         RPA : Use RPA dielectric function to calculate
%                               screening of core-hole. 
{
|X| S
} .inp_feff.corehole

# TARGET
feff.target
% feff.target{ ic }
% Specifies the location of the absorber atom for reciprocal space calculations. It is entry ic of the
% feff.ATOMS card if an feff.ATOMS card and feff.LATTICE card are used. In conjunction with the cif_input
% card it is entry ic the list of atoms as given in the ‘.cif’ file (i.e., a list of the crystallographically
% inequivalent atom positions in the unit cell). The target needs to be specified also for NOHOLE
% calculations. Note that this cannot be specified in the feff.POTENTIALS list because periodic
% boundary conditions would then produce an infinite number of core holes.
% * calculate a spectrum for the second atom in the feff.ATOMS list or CIF file.
% feff.TARGET{ 2 }
{
|X| I
} .inp_feff.absorber

# EGRID
feff.egrid
% This card can be used to customize the energy grid. The EGRID card is followed by lines
% specifying the type of grid, minimum and maximum values for the grid, and the grid step, i.e.
%
% grid_type grid_min grid_max grid_step
%
% The grid type parameter is a string that can take the values e_grid, k_grid, or exp_grid. When
% using the e_grid or k_grid grid types, grid_min, grid_max, and grid_step are given in eV or Å −1
% respectively. For the exp_grid type, grid_min and grid_max are the minimum and maximum
% grid values in eV, and grid_step is the exponential, i.e. 
%
%   E_i = E_Min + (E_max-E_Min)*[exp(grid_step ∗ i) − 1.0].
%
% A fourth grid type user grid is also available for feff. user grid is followed by an arbitrary
% number of lines, each specifying an energy point in eV , i.e.,
% user_grid
% 0.1
% 1.5
% 3.45
% 6.0
% .
% .
% .
{
|X| S S F F
|X| ...
} .inp_feff.egrid

# COORDINATES
feff.coordinates
% feff.coordinates{ i }
% i must be an integer from 1 through 6. It specifies the units of the atoms of the unit cell given
% in the ATOMS card for reciprocal space calculations. If the card is omitted, the default value
% icoord = 3 is assumed. FIX check this
% 1. Cartesian coordinates, Angstrom units. Like feff - you can copy from a real-space
% feff.inp file if your lattice vectors coincide with atoms in that feff.inp file.
% 2. Cartesian coordinates, fractional units (i.e., fractions of the lattice vectors ; should be
% numbers between 0 and 1). Similar to feff.
% 3. Cartesian coordinates, units are fractional with respect to FIRST lattice vector. Like
% SPRKKR. (default)
% 4. Given in lattice coordinates, in fractional units. Like WIEN2k (but beware of some
% ‘funny’ lattice types, e.g. rhombohedral, in WIEN2k case.struct if you’re copy-pasting )
% 5. Given in lattice coordinates, units are fractional with respect to FIRST lattice vector.
% 6. Given in lattice coordinates, Angstrom units.
{
|X| I
} .inp_feff.coordinates

# EXTPOT
feff.extpot
% Not currently workding. Do not use.
{
|X| L
} .inp_feff.extpot

# CHBROAD
feff.chbroad
% feff.chbroad{ ichbroad }
% Set method of calculating core-hole lifetime broadening.
% ichbroad -
%            0: Calculate Green's function at energy with imaginary part equal
%               to Gamma_CH/2.
%            1: Convolve final spectrum with Lorenzian of full width at
%               half-max Gamma_ch.
{
|X| I
} .inp_feff.chbroad

# CHSH
feff.chsh
% feff.chsh{ ich }
% Correct chemical shift.
% ich = 0 or 1.
{
|X| I
} .inp_feff.chsh

# DIMS
feff.dims
% feff.dims{ nmax lmax }
% Set maximum dimensions for fms calculations.
% nmax - maximum number of atoms in fms matrix.
% lmax - maximum angular momentum of fms matrix.
{
|X| I I
} .inp_feff.dims

# NRIXS
feff.nrixs
{
|X| I 
|X| F ...
|X| ...
} .inp_feff.nrixs

# LJMAX
feff.ljmax
% For use in calculations of NRIXS. Not implemented yet.
{
|X| I
} .inp_feff.ljmax

# LDEC
feff.ldec
% For use in calculations of NRIXS. Not implemented yet.
{
|X| I
} .inp_feff.ldec

# SETEDGE
feff.setedge
% feff.setedge{ UseEdgeTable }
% Use table of experimental edge energies.
{
|X| L
} .inp_feff.setedge

# EPS0
feff.eps0
% feff.eps0{ eps0 }
% Set dielectric constant used for many-pole self-energy calculations.
{
|X| F
} .inp_feff.eps0

# OPCONS
opcons.usesaved
% feff.opcons{ }
% Calculate loss function using an atomic approximation.
{
|X| L
} .inp_opcons.usesaved

feff.opcons
% Calculate the dielectric function of the material within the 
% atomic approximation. Very fast. Used to calculate loss.dat for
% use with feff.mpse self-energy calculations.
{
|X| L
} .inp_opcons.usesaved

# NUMDENS
feff.numdens
{
|X| I F
|X| ...
} .inp_feff.numdens

# PREPS
feff.preps
% feff.preps{ PrintEpsilon }
% Print dielectric function as calculated by feff.opcons.
{
|X| L
} .inp_feff.preps

# EGAPSE
feff.egapse
% feff.egapse{ egap }
% Use this gap energy when applying the many-pole self-energy.
{
|X| F
} .inp_feff.egapse

# CHWIDTH
feff.chwidth
% feff.chwidth{ gamma_ch }
% Set core-hole width instead of using FEFF's internal table of widths.
{
|X| F
} .inp_feff.chwidth

# MDFF - will implement in future
#feff.mdff
#{
#|X| I 
#} .inp_feff.

# RESTART
feff.restart
% Not implemented yet.
{
|X| L
} .inp_feff.restart

# CONFIG
feff.config
% Not implemented yet.
{
|X| S
|X| ...
} .inp_feff.config

# SCREEN
feff.screen
% The screen module, which calculates the RPA core hole potential, is a ’silent’ module: it has
% no obvious input but instead runs entirely on default values. Using the feff.SCREEN card you
% can change these default values. They will be written to an optional ‘screen.inp’ file (which
% you can also edit manually). The feff.SCREEN card can occur more than once in ‘feff.inp’; all
% entries will be applied to the calculation. parameter must be one of : ner (40), nei (20), maxl
% (4), irrh (1), iend (0), lfxc (0), emin (-40 eV), emax (0 eV), eimax (2 eV), ermin (0.001 eV),
% rfms (4.0), nrptx0 (251). For most calculations the default values given (between brackets) are
% fine. Occasionally we’ve changed rfms, maxl, or emin. Note that the screen is only active with
% feff.COREHOLE{ RPA }.
% * Set the cluster radius for the RPA potential calculation higher than the default of 4.0
% feff.COREHOLE{ RPA }
% feff.SCREEN{ rfms 5.0 }
{
# We will also want to improve this interface.
|X| S S
|X| ...
} .inp_feff.screen

# CIF
feff.cif
% Specify a cif input file. Dangerous. Use cif_input instead.
{
|X| S
} .inp_feff.cif

# EQUIVALENCE
feff.equivalence
% feff.equivalence{ ieq }
% This optional card is only active in combination with the CIF card. It tells feff how to
% generate potential types from the list of atom positions in the ‘cif’ file.
% If ieq = 1, the crystallographic equivalence as expressed in the ‘cif’ file is respected; that
% is, every separate line containing a generating atom position will lead to a separate potential
% type. This means that, e.g., in HOPG graphite, the two generating positions will give rise to
% two independent C potentials. This is also the default behavior if the EQUIVALENCE card is
% not specified.
% If ieq = 2, unique potentials are assigned based on atomic number Z only. That is, all
% C atoms will share a C potential and so on. This is how most feff calculations are run.
% Whether it is sensible or not to do this depends on the system and on the property one wishes
% to calculate. Keep in mind that feff is a muffin tin code, and may therefore be indifferent
% to certain differences between crystallographically inequivalent sites. On the other hand, if
% an element occurs in the crystal with different oxidation states, it may be necessary to assign
% separate potentials to these different types in order to describe the crystal properly and get
% accurate spectra.
% If ieq = 3, unique potentials are assigned based on atomic number Z and the first shell.
% This can be useful e.g. to treat larger systems with crystal defects, where only first neighbors
% of the defect need to be treated differently from all more distant atoms of a certain Z. (To be
% implemented.)
% If ieq = 4, a hybrid of methods 1 and 2 is used. That is, if the number of unique crystallo-
% graphic positions does not exceed a hard-coded limit (nphx=9 in the current version), they are
% treated with the correct crystallographic equivalence. If the number of unique crystallographi-
% cally inequivalent sites is larger, they get combined by atomic number Z. This ad hoc approach
% is a practical way of simply limiting the number of unique potentials. This makes sense be-
% cause, first of all, there are certain hardcoded limits that would require recompilation of the
% code, requiring more RAM memory and more work than a user may want to do. 
{
1 |X| I
} .inp_feff.equivalence

feff.equivalence.nmax
{
|X| I
}.inp_feff.equivalence.nmax

# COMPTON
feff.compton
% Not implemented yet.
{
|X| F I I
} .inp_feff.compton

# RHOZZP 
feff.rhozzp
% Not implemented yet.
{
|X| L
} .inp_feff.rhozzp

# CGRID
feff.cgrid
% Not implemented yet.
{
|X| F I I I I
} .inp_feff.cgrid

# CORVAL
feff.corval
% feff.corval{ emin }
% The core-valence separation energy is found by scanning the DOS within an energy window.
% The emin parameter sets the lower bound (in eV) of this energy window. It is 70 eV by
% default. For some materials it is necessary to lower this bound, e.g. to 100 eV. For example,
% when SCF convergence is elusive because occupation numbers for one or more l-values are
% changing drastically between SCF iterations due to states moving above and below a poor
% estimate of the core-valence separation energy. We plan to replace the current mechanism by a
% more robust and automated algorithm, but in the meantime users can use the CORVAL card
% to handle some of these difficult cases.
{
|X| F
} .inp_feff.corval

# SIGGK
feff.siggk
% Not implemented yet.
{
|X| F
} .inp_feff.siggk

# TEMPERATURE
feff.temperature
% feff.temperature{ etemp iscfxc }
% The TEMP card sets the electronic temperature and the exchange-correlation potential. etemp
% = 0 (default). etemp is in eV. There are 4 different options for the exchange-correlation
% potential.
% iscfxc
%    No temperature dependent exchange correlations
%       11 von-Barth Hedin 1971 (default)
%       12 Perdew-Zunger
%    Explicitly temperature dependent exchange correlations
%       21 Perrot Dharma-Wardana 1984
%       22 KSDT (recommended)
{
|X| F I
} .inp_feff.temperature

# DENSITY
feff.density
% Not implemented yet.
{
# den_type, grid_type, outfile
|X| S S S 
# origin
|X| F F F
# number of points in each direction
|X| I I I
# vectors along which to step
|X| F F F
|X| F F F
|X| F F F
} .inp_feff.density

# RIXS
feff.rixs
% feff.RIXS {gam_Ei gam_El xmu}
% The RIXS card sets the parameters for the RIXS calculation. It must be used with a workflow
% or script to produce RIXS.

% gam_Ei
%    Broadening to use in the incident energy direction.
%
% gam_El
%    Broadening to use in the energy loss direction.
% 
% xmu
%    Fermi energy to use for the RIXS calculation, if not present, the fermi level calculated in
%    the SCF step will be used.
{
|X| F F F
} .inp_feff.rixs

# RLPRINT
feff.rlprint
% Advanced used in RIXS calculations, but automated by corvus. Prints real scattering wavefunction R_l.
{
|X| L
} .inp_feff.rlprint

# HUBBARD
feff.hubbard
% Not currently working.
{
|X| F F F I
} .inp_feff.hubbard

# CRPA
feff.crpa
% Not currently working.
{
|X| I F
} .inp_feff.crpa

# SCXC
feff.scxc
{
|X| I
} .inp_feff.scxc

#------------------------------------------------------------------------------
##############################################
#
#    ORCA 
#
##############################################
#
# Keywords - set multiple settings
# 
orca.expert
% Use verbatim expert setting for orca.
{
|X| S ...
|X| ...
} .inp_orca.expert
orca.scf.convergencestrategy
{
NormalConv |X| S
} .inp_orca.scf.convergencestrategy

orca.cpcm
{
|X| S
} .inp_orca.cpcm

# Method block input
#
orca.method.method
{
B3LYP |X| S
} .inp_orca.method.method

orca.method.runtype
{
OPT |X| S
} .inp_orca.method.runtype

orca.method.amass
{
Mass2016 |X| S
} .inp_orca.method.amass

orca.method.usesymm
{
F |X| L
} .inp_orca.method.usesymm

orca.method.frozencore
{
F |X| L
} .inp_orca.method.frozencore

orca.method.allowrhf
{
F |X| L
} .inp_orca.method.allowrhf

orca.method.ri
{
F |X| L
} .inp_orca.method.ri

orca.method.grid
{
GRID4 |X| S
} .inp_orca.method.grid

orca.method.gridx
{
|X| S
} .inp_orca.method.gridx


# SCF controls
orca.scf.hftyp
{
RHF |X| S
} .inp_orca.scf.hftyp

orca.scf.fracocc
{
|X| S
} .inp_orca.scf.fracocc

orca.scf.smeartemp
{
|X| L
} .inp_orca.scf.smeartemp

orca.scf.keepints
{
|X| L
} .inp_orca.scf.keepints

orca.scf.keepdens
{
|X| L
} .inp_orca.scf.keepdens

orca.scf.readints
{
|X| L
} .inp_orca.scf.readints

orca.scf.usecheapints
{
|X| L
} .inp_orca.scf.uescheapints

orca.scf.valformat
{
|X| S
} .inp_orca.scf.valformat


orca.scf.kmatrix
{
|X| S
} .inp_orca.scf.kmatrix

orca.scf.jmatrix
{
|X| S
} .inp_orca.scf.jmatrix

orca.scf.scfmode
{
|X| S
} .inp_orca.scf.scfmode

orca.scf.maxiter
{
|X| S
} .inp_orca.scf.maxiter

orca.scf.guess
{
|X| S
} .inp_orca.scf.guess

orca.scf.autostart
{
T |X| L
} .inp_orca.scf.autostart

orca.scf.convergence
{
NORMALSCF |X| S
} .inp_orca.scf.convergence

orca.scf.diis
{
|X| L
} .inp_orca.scf.diis

orca.scf.kdiis
{
|X| L
} .inp_orca.scf.kdiis

orca.scf.nr
{
|X| L
} .inp_orca.scf.nr

orca.scf.soscf
{
|X| L
} .inp_orca.scf.soscf

orca.scf.cnvdamp
{
|X| L
} .inp_orca.scf.cnvdamp

orca.scf.cnvshift
{
|X| L
} .inp_orca.scf.cnvshift

orca.scf.uno
{
|X| L
} .inp_orca.scf.uno



# Basis block
orca.basis.basis
{
def2-TZVP |X| S
} .inp_orca.basis.basis

orca.basis.decontract
{
|X| L
} .inp_orca.basis.decontract


# MP2 controls
orca.mp2
{
F |X| L
} .inp_orca.mp2

orca.mp2type
{
MP2 |X| S
} .inp_orca.mp2type

# Single reference CI controls (MDCI block)
orca.ci
{
F |X| L
} .inp_orca.ci

orca.citype
{
CCSD |X| S
} .inp_orca.citype

# GEOM block
orca.tole
{
|X| F
} .inp_orca.tole

orca.tolrmsg
{
|X| F
} .inp_orca.tolrmsg

orca.tolmaxg
{
|X| F
} .inp_orca.tolmaxg

orca.tolrmsd
{
|X| F
} .inp_orca.tolrmsd

orca.tolrmaxd
{
|X| F
} .inp_orca.tolrmaxd

orca.geom.optimizationquality
{
TIGHTOPT |X| S
} .inp_orca.geom.optimizationquality

# coordinate input block
orca.coords.units
{
|X| S
} .inp_orca.coords.units


# Relativistic options
orca.rel.method
{
|X| S
} .inp_orca.rel.method

orca.rel.soctype
{
|X| S
} .inp_orca.rel.soctype

# Output options
orca.output.printlevel
{
|X| S
} .inp_orca.output.printlevel

orca.output.print
{
|X| S
} .inp_orca.output.print

orca.output.xyzfile
{
|X| L
} .inp_orca.output.xyzfile

orca.output.pdbfile
{
|X| L
} .inp_orca.output.pdbfile


#------------------------------------------------------------------------------
##############################################
#
#    TD-SIESTA 
#
##############################################
#
# Keywords - set multiple settings
# 
#
#
#------------------------------------------------------------------------------
siesta.MPI.CMD{
|X| S
} .inp_siesta.MPI.CMD
siesta.MPI.ARGS{
|X| S ...
} .inp_siesta.MPI.ARGS
siesta.TD.NumberOfTimeSteps
% Specify number of time steps for RT-TDDFT run. 
{
|X| I
} .inp_siesta.TD.NumberOfTimeSteps

siesta.PAO.EnergyShift{
% Specify energy shift to control basis cutoff radii.
|X| F S
}.inp_siesta.PAO.EnergyShift
siesta.TD.TimeStep
% Specify the time step for RT-TDDFT run.
{
|X| F
} .inp_siesta.TD.TimeStep

siesta.TD.ShapeOfEfield
% Specify the shape of the field for the RT-TDDFT run.
% Options are:
% step     - Turn off dipole field at time 0.
% halfstep - Dipole field changes from full strength to 1/2
%            strength at time 0.
% delta    - Dipole field with time dependence delta(t).
% const    - Turn on dipole field at time 0.
% sine     - Dipole field with damped sine wave time dependence,
%            with optional Gaussian envelope to create quasi-harmonic
%            wave packet.
% core     - turn on core-hole potential at time 0.
% core2    - GS with full core-hole. Excited states from linear response after.
{
|X| S
} .inp_siesta.TD.ShapeOfEfield

siesta.TD.CoreExcitedAtom
% Set which atom will be the absorbing atom, i.e., which atoms the
% core-hole will be centered on
{
|X| I
} .inp_siesta.TD.CoreExcitedAtom

siesta.TD.CorePerturbationCharge
% Set the core-hole charge. 
{
|X| F
} .inp_siesta.TD.CorePerturbationCharge

siesta.TD.mxPC
% Maximum number of points to use for predictor-corrector algorith.
{
2 |X| I
} .inp_siesta.TD.mxPC

siesta.Diag.DivideAndConquer
{
|X| S
} .inp_siesta.Diag.DivideAndConquer
siesta.LongOutput
% Output lots of info.
{
T |X| L
} .inp_siesta.LongOut

siesta.MeshCutoff
% Energy that defines the real-space grid. Point spacing scales as 1/sqrt(E_c).
{
120.0 Ry |X| F S
} .inp_siesta.MeshCutoff

siesta.XC.functional
% Set flavor of exchange-correlation functional, i.e., LDA or GGA.
{
GGA |X| S
} .inp_siesta.XC.functional

siesta.XC.authors
% Set authors of exchange correlation functional.
{
PBE |X| S
} .inp_siesta.XC.Authors

siesta.LatticeConstant
% Set an overall multiplicative constant for the lattice parameters.
{
|X| F S
} .inp_siesta.LatticeConstant

siesta.Block.PAO.Basis
% Set siesta basis manually
{
|X| S ...
|X| ...
} .inp_siesta.Block.PAO.Basis

siesta.Block.LatticeParameters
% Set lattice parameters, i.e.,
% a b c alpha beta gamma
{
|X| F F F F F F
}.inp_siesta.Block.LatticeParameters

siesta.MaxSCFIterations
% Max number of SCF iterations allowed.
{
100 |X| I
} .inp_siesta.MaxSCFIterations

siesta.UseSaveData
% Use saved data to start siesta calculation
{
F |X| L
} .inp_siesta.UseSaveData

siesta.DM.InitSpin.AF
% Set magnetic behavior of system to antiferromagnetic if true. 
% Default is false and will be set up as ferromagnetic.
{
|X| L
} .inp_siesta.DM.InitSpin.AF

siesta.SpinPolarized
% Include spin in calculation.
% Value should be yes or no.
{
|X| S
} .inp_siesta.SpinPolarized
siesta.DM.NumberBroyden
% Set number of broyden steps
{
|X| I
} .inp_siesta.DM.NumberBroyden

siesta.DM.NumberPulay
% Set number of Pulay steps
{
|X| I
} .inp_siesta.DM.NumberPulay

siesta.DM.MixingWeight
% Mixing weight for the density matrix.
{
0.10 |X| F
} .inp_siesta.DM.MixingWeight

siesta.DM.Tolerance
% Convergence tolerance for elements of the density matrix
{
1.0e-4 |X| F
} .inp_siesta.DM.Tolerance

siesta.SolutionMethod
% Method for solving the eigenvalue problem.
{
diagon |X| S
} .inp_siesta.SolutionMethod

siesta.PAO.BasisType
% Define basis type
% split: Split-valence scheme for multiple-zeta. The split is based on different radii.
% splitgauss: Same as split but using Gaussian functions.
% nodes: Generalized PAO’s.
% nonodes: The original PAO’s are used, multiple-zeta is generated by changing the
% scale-factors, instead of using the excited orbitals.
% filteret: Use the filterets as a systematic basis set. The size of the basis set is
% controlled by the filter cut-off for the orbitals.
{
split |X| S
} .inp_siesta.PAO.BasisType

siesta.PAO.BasisSize
% Define basis size. Can be SZ, DZ, SZP, DZP.
{
DZP |X| S
} .inp_siesta.PAO.BasisSize


siesta.ElectronicTemperature
% Set electronic teperature used to define occupation numbers during SCF.
{
1.0 K |X| F S
} .inp_siesta.ElectronicTemperature

siesta.NumberOfAtoms
% Indicate number of atoms in unit cell.
{
|X| I
} .inp_siesta.NumberOfAtoms

siesta.NumberOfSpecies
% Indicate number of species in unit cell.
{
|X| I
} .inp_siesta.NumberOfSpecies

siesta.Block.ChemicalSpeciesLabel
% Indicate the different chemical species in the unit cell.
% Format:
% SpeciesIndex1 AtomicNumber1 AtomicSymbol1
% SpeciesIndex2 AtomicNumber2 AtomicSymbol2
% ...
{
|X| I I S
} .inp_siesta.Block.ChemicalSpeciesLabel

siesta.AtomicCoordinatesFormat
% Specify units and format of atomic coordinates.
% Borh            - cartesian in Bohr.
% Ang             - cartesian in Angstrom.
% ScaledCartesian - cartesian scaled by lattice constant.
% Fractional      - coordinates are given in units of the lattice vectors.
{
Fractional |X| S
} .inp_siesta.AtomicCoordinatesFormat

siesta.Block.AtomicCoordinatesAndAtomicSpecies
% Specify coordinates of each atom as well as the species index.
% x1 y1 z1 SpeciesIndex1
% x2 y2 z2 SpeciesIndex2
% ...
{
|X| F F F I
|X| ...
} .inp_siesta.Block.AtomicCoordinatesAndAtomicSpecies

#Added by Charles
siesta.DM.NumberBroyden
{
|X| I
} .inp_siesta.DM.NumberBroyden

siesta.Coreresponse.Broadening
{
0.5 |X| F
} .inp_siesta.Coreresponse.Broadening

siesta.Beta.Broadening
{
0.1 |X| F
} .inp_siesta.Beta.Broadening

siesta.expert
{
|X| S ...
|X| ...
} .inp_siesta.expert

#Added by Charles
# Inputs for phsf handler

phsf.numtimepoints
{
40000 |X| I
} .inp_phsf.numtimepoints

phsf.broadening
{
0.5 |X| F
} .inp_phsf.broadening

phsf.ekeqp
{
0.0 0.0 |X| F F
} .inp_phsf.ekeqp
#------------------------------------------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% cif2cell input
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

cif2cell.cif_input
% Crystallographic information file to use.
{
|X| S
} .inp_cif2cell.cif_input

cif2cell.program
{
% Program for cif2cell to write input for.
|X| S
} .inp_cif2cell.program

cif2cell.outfile
% Write output to outfile
{
|X| S
} .inp_cif2cell.outfile

cif2cell.supercell
{
|X| I I I
} .inp_cif2cell.supercell

cif2cell.cartesian
% make output in cartesian form
{
|X| L
} .inp_cif2cell.cartesian

cif2cell.atomicunits
% print coordinates in bohr rather than angstroms
{
|X| L
} .inp_cif2cell.atomicunits


##############################################
#
#   cfavg input
#
##############################################
cfavg_target
{
|X| S
} .inp_cfavg.target

cfavg.max_configurations
{
|X| I
} .inp_cfavg.max_configurations

cfavg.choose_random_absorbers
{
False |X| L
} .inp_cfavg.choose_random_absorbers

##############################################
#
#   fit input
#
##############################################
fit.target
{
|X| S
} .inp_fit.target

fit.parameters
{
|X| S F
|X| ...
} .inp_fit.parameters

fit.datafile
{
|X| S
} .inp_fit.datafile

fit.bond
{
|X| I ...
|X| ...
} .inp_fit.bond


##############################################
#
#   OCEAN input
#
##############################################

ocean.photon.operator
% Select the operator to be used to calculate the (diple or quad)
{
dipole |X| S
} .inp_ocean.photon.operator

ocean.photon.polarization
% Direction of polarization for XANES or XES calculations
{
|X| F F F
} .inp_ocean.photon.polarization

ocean.photon.qhat
% Direction of q-vector for quadrupole or NRIXS calculations
{
|X| F F F
} .inp_ocean.photon.qhat

ocean.photon.energy
% Set energy of x-rays at edge
{
|X| F
} .inp_ocean.photon.energy

# Run control
ocean.para_prefix
% Set the command to use for parallel runs, i.e., mpirun, mpiexec etc,
% along with any flags to use.
{
|X| S ...
} .inp_ocean.para_prefix

ocean.ser_prefix
% prefix for serial parts of the code, for example, cut3d should be run
% with only 1 processor, i.e., mpirun -n 1
{
|X| S ...
} .inp_ocean.ser_prefix

ocean.dft
% Which DFT code to use: qe - QuantumEspresso, abi - ABINIT
{
abi |X| S
} .inp_ocean.dft

ocean.scratch
% Where to write scratch files
{
|X| S
} .inp_ocean.scratch

# structure

ocean.acell
% Scaling in Bohr for the primitive vectors of the unit cell
{
|X| F F F
} .inp_ocean.acell

ocean.rprim
% Primitive vectors of unit cell
{
|X| F F F
|X| F F F
|X| F F F
} .inp_ocean.rprim

ocean.ntypat
% Number of different types (usually species) of atom in the unit cell.
{
|X| I
} .inp_ocean.ntypat

ocean.znucl
% List of length ntypat with atomic numbers of each type of atom in the unit cell
{
|X| I ...
} .inp_ocean.znucl

ocean.natom
% Number of atoms in the unit cell
{
|X| I
} .inp_ocean.natom

ocean.typat
% Type of each atom in the unit cell denoted by the integer index corresponding
% to the ocean.znucl list of atomic numbers. This list must be in the same 
% as the coordinates listed in ocean.xred
{
|X| I ...
} .inp_ocean.typat

ocean.xred
% Reduced coordinats of atoms in the unit cell.
{
|X| F F F
|X| ...
} .inp_ocean.xred

ocean.diemac
% Macroscopic dielectric matrix.
{
|X| F
} .inp_ocean.diemac

ocean.nspin
% Choose paramagnetic (nspin = 1), or spin dependent (nspin = 2).
{
|X| I
} .inp_ocean.nspin

ocean.smag
% Controls initial magnetism for the DFT calculations. 
{
|X| I I I
|X| ...
} .inp_ocean.smag

ocean.smag.ixc
% Used for abinit runs in smag card. Don't know the meaning at the moment. 
% This should be combiened with ocean.smag to write the card to the ocean
% input.
{
|X| I
} .inp_ocean.smag.ixc

ocean.ldau
% Controls the U parameters for the DFT run. Only works with QuantumEspresso
% currently. Not sure what the parameters are, but I believe they are 
% logical flag to run/not run LDA+U, U for each atom that has spin 
% associated with smag.
{
|X| L
|X| F
|X| ...
} .inp_ocean.ldau

ocean.zymb
% For use with QE. Each element listed in ocean.znucle can have a symbol
% associated with it.
{
|X| S ...
} .inp_ocean.zymb

# DFT
ocean.pp_list
% Names of the pseudopotential files to be used listed in the same order as
% ocean.znucl
{
|X| S 
|X| ...
} .inp_ocean.pp_list

ocean.ecut
% Plane wave basis truncation energy in Rydberg
{
|X| F
} .inp_ocean.ecut
 
ocean.nkpt
% Number of k-points in each direction used to sample the 
% cell for the calculation of the 
% final states.
{
|X| I I I
} .inp_ocean.nkpt

ocean.ngkpt
% Number of k-points in each direction used to sample the cell for 
% the ground-state calculation of the density. 
{
|X| I I I
} .inp_ocean.ngkpt

ocean.nbands
% Number of bands for the final state calculations. This includes valence and conduction bands.
{
|X| I
} .inp_ocean.nbands

ocean.screen.nbands
% Number of bands to use for the screening calculations. This requires a large
% number of bands. Should be about 100eV above the Fermi level, but convergence
% should be checked.
{
|X| I
} .inp_ocean.screen.nbands

ocean.occopt
% Controls determination of occupation. Most important 
% values are: 
% 1 - States are all doubly degenerate and either occupied or empty depending on band.
% 3 - States are all doubly degenerate but can have fractional occupations 
%     depending on Fermi function. Suitable for metals.
{
|X| I
} .inp_ocean.occopt

ocean.fband
% Determines the number of occupied bands to be included in the SCF calculation
% of the density. For insulators the default (fband = 0.125) is fine, but 
% for metals the highest band the in the density calculation should have no
% occupation weight. Using fband, the number of bands is determined by 
% n = natom*fband.
{
|X| F
} .inp_ocean.fband

ocean.toldfe
% Total energy convergence parameter for the density run. Default is 10^(-6)
{
|X| F
} .inp_ocean.toldfe
 
ocean.tolwfr
% Convergence criterium for the non-scf wave-function calculations. 
% Default is 10^(-16)
{
|X| F
} .inp_ocean.tolwfr

ocean.nstep
% Maximum number of iterations for the DFT SCF calculations. Default is 50
{
|X| I
} .inp_ocean.nstep

ocean.screen.nkpt
% Number of k-point to be used for the screening calculations. Default is 2 2 2,
% and is sufficient for a wide variety of systems, although very small unit 
% cells might require more, and large unit cells may only require gamma point.
{
|X| I I I
} .inp_ocean.screen.nkpt

ocean.abpad
% For the calculation of the final state wavefunctions, the convergence of the
% highest bands can be very slow. The calculation can be sped up by adding some
% throwaway bands at teh top. These bands are not considered when checking for convergence. ocean.abpad adds bands to the calculation. Only used for abinit.
{
|X| I
} .inp_ocean.abpad

ocean.dft_energy_range
% Instead of setting the number of bands (ocean.nbands) the user may request 
% an energy range in eV for the final state wave-functions. This is an estimate
% using the volume of the unit cell and may be unreliable. Default is 25 eV.
{
|X| F
} .inp_ocean.dft_energy_range

ocean.screen_energy_range
% Instead of setting number of bands for the screening, the user may request 
% an energy range in eV. This is only an estimate, and may need to be converged.
{
|X| F
} .inp_ocean.screen_energy_range

ocean.k0
% DFT states are calculated using a shifted k-point grid. The first k-point is 
% given by:
%   1/(N_k(1)*k0(1)), 1/(N_k(2)*k0(2), 1/(N_k(3)*k0(3)
% where N_k is given by ocean.nkpt. The default shift is k0 = 1/8, 2/8, 3/8.
{
|X| F F F
} .inp_ocean.k0

ocean.degauss
% Broadening for the smearing function in Ryd. for metallic occupations in the
% DFT calculations.
{
|X| F
} .inp_ocean.degauss

# Atomic and screening
ocean.opf.program
% Use oncvpsp UPS pseudopotentials with qe
{
|X| S
} .inp_ocean.opf.program

ocean.opf.fill
% atomic number followed by the name of the .fill file to use for this calculation.
{
|X| I S
} .inp_ocean.opf.fill

ocean.opf.opts
% atomic number followed by the name of the .opts file to use for this calculation.
{
|X| I S
} .inp_ocean.opf.opts

ocean.edges
% Specify the atoms and edges to calculate. Each edge entry consists of 3
% integers. The first, if greater than zero, is the index of the atom for
% which the edge should be calculated. The second and third numbers are the
% principle quantum number and angular momentum. 
% '1 2 1' denotes the L edges of the first atom
% If the first number is negative, then it is interpreted as -Z, where 
% Z is the atomic number, and in that case edges of all atoms with that 
% atomic number will be calculated.
% '-22 2 1' will run the L edges of every titanium atom in the cell.
{
|X| I I I
|X| ...
} .inp_ocean.edges

ocean.screen.shells
% The screening calculation is RPA at small radius and a model at large radius.
% Teh cross-over between the RPA and model is set by shells in Bohr. 
% Several different radii can be chosen to look at the convergence. 
% Convergence is usually reached at arount 3-4 Bohr. The supercell defined by 
% ocean.paw.nkpt must have dimensions larger than the radius specified by 
% ocean.screen.shells or results may be unreliable. The default of 3.5 Bohr is
% usually OK. Values > 6 Bohr should not be used.
{
|X| F ...
} .inp_ocean.screen.shells
 
ocean.cnbse.rad
% One of the screening radius as defined by ocean.screen.shells that will be 
% used in the BSE calculation.
{
|X| F
} .inp_ocean.cnbse.rad

ocean.scfac
% The is the Slater integral factor to scale the slater integrals. For 3d 
% transition metals 0.8 is a reasonable value, while 0.6 is better for 
% f-electron atoms.
{
|X| F
} .inp_ocean.scfac

ocean.core_offset
% If true, core-level shift will be calculated, false, no shift, or a number 
% to specify the shift by hand.
{
|X| S
} .inp_ocean.core_offset

ocean.opf.hfkgrid
% The first parameter sets the grid for hfk.x, and should be left at 2000.
% The second determines the maximum number of proejectors per angular momentum 
% channel. The default of 20 will work for many calculations.
{
|X| I I
} .inp_ocean.opf.hfkgrid

# BSE
ocean.cnbse.xmesh
% Wave-functions are converted into the NIST BSE format and condensed onto a 
% grid of size ocean.cnbse.xmesh. Default is guessed in the code.
{
|X| I I I
} .inp_ocean.cnbse.xmesh

ocean.cnbse.mode
% Which spectroscopy to calculate: "XAS", "XES"
% NRIXS and XRS are treated the same as XAS.
{
|X| S
} .inp_ocean.cnbse.mode

ocean.cnbse.niter
% Number of Haydock iterations. Default is 100.
{
|X| I
} .inp_ocean.cnbse.mode

ocean.metal
% If True, the code will complain unless occopt is 3. If False, the codes 
% expects occopt = 1.
{
|X| L
} .inp_ocean.metal

ocean.spin-orbit
% If ocean.spin-orbit >= 0, the code will not automatically calculate the
% spin-orbit splitting. 
{
|X| F
} .inp_ocean.spin-orbit

ocean.photon_q
% For UV/VIS and RIXS calculations, the valence and conduction band states 
% must be offset from each other (by the momentum that is absorbed or 
% transferred). This sets that momentum offset in units of the reciprocal 
% lattice vectors of the system. Default is 0 0 0.
{
|X| F F F 
} .inp_ocean.photon_q

ocean.cnbse.strength
% Sets the strength for the two interaction terms in the BSE Hamiltonian.
% Default is 1, and for emission 0. This can be changed for analysis.
{
|X| F
} .inp_ocean.cnbse.strength

ocean.cnbse.solver
% Choose between Haydock algorithm (full spectrum, no excitons) or GMRES
% (single energy, exciton density).
{
|X| S
} .inp_ocean.cnbse.solver

ocean.cnbse.gmres.elist
% List of energies at which to run the GMRES algorithm in eV. Lowest 
% unoccupied state is set at zero without the core-hole. 
{
|X| F ...
} .inp_ocean.cnbse.gmres.elist

ocean.cnbse.gmres.erange
% Use energies at with even spacing specified by 
% emin emax estep
{
|X| F
} .inp_ocean.cnbse.gmres.erange

ocean.cnbse.gmres.nloop
% Restart GMRES algorithm will restart if the subspace grows to size nloop. 
{
|X| I
} .inp_ocean.cnbse.gmres.nloop

ocean.cnbse.gmres.gprc
% Set Lorenzian broadening in Hartree in the GMRES algorithm when 
% pre-conditioning. Default is 0.5, which should be reasonable for K edges.
{
|X| F
} .inp_ocean.cnbse.gmres.gprc

ocean.cnbse.gmres.ffff
% Sets convergence criterion for GMRES.
{
|X| F
} .inp_ocean.cnbse.gmres.ffff

# Spectrum
ocean.cnbse.broaden
% Half? width of broadening in eV for the spectrum. Must be larger than zero. 
% Suggested value is the core-hole broadening. 
{
|X| F
} .inp_ocean.cnbse.broaden

ocean.cnbse.spect_range
% Sets energies over which the spectrum will be calculated. 
% nsteps emin emax 
{
|X| I F F
} .inp_ocean.cnbse.spect_range

